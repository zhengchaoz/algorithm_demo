package com.algorithm.demo.strategy.mergesort;

import com.algorithm.demo.strategy.AlgorithmStrategy;

/**
 * 多路归并排序(外部排序)
 *
 * 具体思路：1.将大数据文件尽量拆分成大小均等的若干子文件
 *         2.利用内部排序对所有子文件分别进行排序（可以利用线程）
 *         3.将排好序的子文件同时归并成一个完整的文件，可以利用数组、最小堆（小顶堆）、败者树
 *         4.由于读取磁盘文件速度慢，可以设立缓冲区提前加载
 *
 * 归并思路：由于所有子文件都是有序的，可以将各个子文件的第一个元素放入数组、最小堆（小顶堆）、败者树中，
 *         经过排序获得这批元素的最小值，将最小值输出后从该值所属的文件中获得下一个元素加入，
 *         重新排序后重复以上步骤。
 *
 * 胜者树和败者树：两者都是完全二叉树，并且需要排序的数据都在叶子节点，非叶子节点和根节点只是记录位置，
 *              即每个每个叶子节点都相当于一个选手，每个节点都相当于一轮比赛，每一层就相当于一轮比赛，
 *              不同的是胜者树的中间节点记录的是胜利者的标号，败者树的中间节点记录的是败者树的标号，
 *              另外败者树还要额外记录一个胜者
 *         注意：胜者树和败者树和顺序无关，即可选出最大值也可以选出最小值
 *
 * 最小堆、胜者树、败者树：当最小堆需要重构时——加入新的元素需要重新排序时，子节点不仅要和兄弟节点比较，
 *                     还要和父节点比较；胜者树重构时子节点仅需要和兄弟节点比较；败者树重构时子节点
 *                     仅需要和父节点比较，并且不用访问兄弟节点，所以优先选败者树
 *
 * @author
 * @date 2021-03-05-17:15
 */
public class ArrayMultiLineMergeSort extends AlgorithmStrategy
{
    @Override
    public void sort(Object o) {

    }

    @Override
    public Object find(Object o) {
        return null;
    }
}
